装饰者模式
动态的将责任附加到对象上。
若要扩展功能，装饰者提供了比继承更有弹性的替代方案
比如有时候我们希望给某个对象而不是整个类添加一些功能！

装饰者 和 被装饰者 必须是一样的类型
也就是有共同的超类，这是相当关键的地方。
在这个模式里面，用继承达到“类型匹配” 而不是用继承来“获得行为”


一个自己归纳的模板：

类型X 对象A = new 类型X();
对象A = 装饰者(对象A); 


class 装饰者{
   类型X 本地对象C; 
	构造方法(类型X 对象){
		本地对象C = 对象;
	}
	
	//借由构造函数获得并保存 要装饰的对象实例 然后可以随便做修改
}